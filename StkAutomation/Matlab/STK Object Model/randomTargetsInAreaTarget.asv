% Start STK
app = actxGetRunningServer('STK12.Application');
root = app.Personality2;
scenario = root.CurrentScenario;

% Grab Area Target and decide which objects to add
values = inputdlg({'Area Target Name','Number of Targets'},...
              'Customer', [1 30; 1 30]);
          
areaTarget = scenario.Children.Item(values{1});
numberOfTargets = round(str2double(values{2}));
if areaTarget.AccessConstraints.IsNamedConstraintActive('ElevationAngle') && areaTarget.AccessConstraints.GetActiveNamedConstraint('ElevationAngle').Angle ~= 90
       currTarget.AccessConstraints.GetActiveNamedConstraint('ElevationAngle').Angle = 90;
else
       cons = currTarget.AccessConstraints.AddNamedConstraint('ElevationAngle');
       cons.Angle = 90;
end

continueAns = questdlg('Add Facilities or Targets', ...
	'Choices', ...
	'Facility','Target','Target');
    switch continueAns
        case 'Facility'
            objectType = 'Facility';
            enumeration = 'eFacility';
        case 'Target'
            objectType = 'Target';
            enumeration = 'eTarget';
    end 


% Find Extents
covDef = scenario.Children.New('eCoverageDefinition','Test');
covDef.Grid.BoundsType = 'eBoundsCustomBoundary';
covDef.Grid.Bounds.BoundaryObjects.AddObject(areaTarget);
covDef.Grid.Resolution.LatLon = 0.5;
pointDP = covDef.DataProviders.Item('Grid Point Locations').Exec;
lats = cell2mat(pointDP.DataSets.GetDataSetByName('Latitude').GetValues);
longs = cell2mat(pointDP.DataSets.GetDataSetByName('Longitude').GetValues);
covDef.Unload;
maxLat = max(lats);
minLat = min(lats);
maxLong = max(longs);
minLong = min(longs);

% Add Objects
for i = 1:numberOfTargets
    latValue = minLat + (maxLat-minLat)*rand;
    longValue = minLong + (maxLong-minLong)*rand;
    name = strcat(objectType, string(i));
    newObj = scenario.Children.New(enumeration,name);
    newObj.Position.AssignGeocentric(latValue,longValue,1);
    access = areaTarget.GetAccessToObject(newObj);
    access.ComputeAccess;
    while ~access.ComputedAccessIntervalTimes.Count
        latValue = minLat + (maxLat-minLat)*rand;
        longValue = minLong + (maxLong-minLong)*rand;
        newObj.Position.AssignGeocentric(latValue,longValue,1);
        access.ComputeAccess;
    end
end 

% Create Point File
fileEnding = '.pnt';
unitlessValue = 'randomValues';
filepath = uigetdir;
newFilepath = strcat(filepath,'\',unitlessValue,fileEnding);
fid = fopen(newFilepath,'w+');
fprintf(fid, 'stk.v.12.0\n\nBEGIN PointList\n\n');
